[
  "article",
  ["h1", "Hooks"],
  [
    "p",
    "React 16.8.0 开始支持Hooks，可以让开发人员使用Function来编写组件，需要注意的是，使用时需要安装相应的React DOM组件。React Hooks是编写React代码的一种方式，如果不喜欢它，可以暂时不用，它是向后兼容的。"
  ],
  ["h2", "Hooks出现解决的问题"],
  [
    "p",
    "在Hooks出现之前，为了复用组件的特性，需要对组件进行重构，并使用高阶组件来实现，随着高阶组件的嵌套层级加深，不利于代码的维护，因此需要一种更加简单清晰的方式，Hooks应运而生，它能更加便利的复用组件特性，且更能独立进行测试。"
  ],
  [
    "p",
    "另外，React生命周期函数的使用，导致某些逻辑分散在多个生命周期函数中，如",
    ["code", "componentDidMount"],
    "和",
    ["code", "componentDidUpdate"],
    "方法可能做着同样的事情，即逻辑代码可能出现2次；",
    ["code", "componentDidMount"],
    "可能负责相关初始化的工作，",
    ["code", "componentWillUnmount"],
    "可能进行清理工作。从而不能很好的体现功能的完整性，容易引入潜在的问题。"
  ],
  [
    "p",
    "组件的状态管理与生命周期紧密联系，状态管理不易抽离与独立，这也是许多开发人员引入第三方的状态管理库的原因，而第三方库的引入，也让代码变得更加复杂。"
  ],
  ["h2", "Hooks为什么采用function而不是Class"],
  [
    "p",
    "经过实践发现，使用",
    ["code", "class"],
    "时，需要理解",
    ["code", "this"],
    "是如何工作的，在绑定事件时，需正确的处理",
    ["code", "this"],
    "的指向；对于何时使用",
    ["code", "function"],
    "和",
    ["code", "class"],
    "，不同人的理解各不一样。"
  ],
  [
    "p",
    "与",
    ["code", "class"],
    "相比，使用",
    ["code", "function"],
    "可以对代码进行更好的优化，如代码压缩、预编译技术（",
    ["code", "Ahead-of-time-compilation"],
    "）、",
    [
      "a",
      {
        "title": null,
        "href": "https://github.com/facebook/react/issues/7323"
      },
      ["code", "Component Folding"]
    ],
    "等，因此，Hooks拥抱",
    ["code", "function"],
    "。"
  ],
  ["h2", "初识Hooks"],
  [
    "pre",
    { "lang": "js" },
    [
      "code",
      "import React, { useState } from 'react';\n\nfunction Example() {\n  // Declare a new state variable, which we'll call \"count\"\n  const [count, setCount] = useState(0);\n  const [fruit, setFruit] = useState('banana');\n  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}"
    ]
  ],
  [
    "p",
    "其中",
    ["code", "useState"],
    "则是众多",
    ["code", "Hooks"],
    "之一，它接收一个参数作为初始化状态数据，返回状态和一个更新状态的函数，如状态",
    ["code", "count"],
    "和函数",
    ["code", "setCount"],
    "；",
    ["code", "useState"],
    "可多次调用，在多次渲染时，它仍会正确的保持相应的状态。"
  ],
  [
    "p",
    ["code", "Hooks"],
    "只能在",
    ["code", "function"],
    "中使用，为了解决",
    ["code", "function"],
    "组件中不能实现",
    ["code", "state"],
    "管理和",
    ["code", "lifecycle"],
    "生命周期管理而出现，相当于",
    ["code", "function"],
    "中",
    ["code", "state"],
    "和",
    ["code", "lifecycle"],
    "的钩子，这也是取名为",
    ["code", "Hooks"],
    "的由来。"
  ],
  ["h2", "内在原理"],
  ["p", "Hooks是如何确保维护正确的状态", ["code", "state"], "呢？如："],
  [
    "pre",
    { "lang": "js" },
    [
      "code",
      "function Form() {\n  // 1. Use the name state variable\n  const [name, setName] = useState('Mary');\n\n  // 2. Use an effect for persisting the form\n  useEffect(function persistForm() {\n    localStorage.setItem('formData', name);\n  });\n\n  // 3. Use the surname state variable\n  const [surname, setSurname] = useState('Poppins');\n\n  // 4. Use an effect for updating the title\n  useEffect(function updateTitle() {\n    document.title = name + ' ' + surname;\n  });\n\n  // ...\n}"
    ]
  ],
  [
    "p",
    "以上代码将在渲染过程中",
    ["code", "useState"],
    "被调用多次，",
    ["code", "name"],
    "与",
    ["code", "surname"],
    "值可能与初始值不一样，React如何保证在调用",
    ["code", "useState"],
    "时，正确地还原",
    ["code", "name"],
    "与",
    ["code", "surname"],
    "值呢？"
  ],
  [
    "p",
    "答案是：",
    ["strong", "通过", ["code", "useState"], "的调用顺序来保证"]
  ],
  ["p", "调用顺序如下："],
  [
    "pre",
    { "lang": "js" },
    [
      "code",
      "// ------------\n// 第一次渲染，执行顺序\n// ------------\nuseState('Mary')           // 1. 初始化变量name为'Mary'\nuseEffect(persistForm)     // 2. 针对Form，设置Form行为\nuseState('Poppins')        // 3. 初始化变量surname为'Poppins'\nuseEffect(updateTitle)     // 4. 针对标题，设置相应行为\n\n// -------------\n// 第二次渲染，执行顺序\n// -------------\nuseState('Mary')           // 1. 读取/还原name变量值，并忽略初始化参数\nuseEffect(persistForm)     // 2. 针对Form，更新Form行为\nuseState('Poppins')        // 3. 读取/还原surname变量值，并忽略初始化参数\nuseEffect(updateTitle)     // 4. 针对标题，更新相应行为\n\n// ..."
    ]
  ],
  [
    "p",
    "因此，只要执行的顺序保持不变，",
    ["code", "Hooks"],
    "则可以正确地维护状态信息，如果执行顺序发生变化，则可能出现问题。"
  ],
  ["p", "例如，将代码修改为，", ["code", "Hooks"], "的执行依赖相关条件："],
  [
    "pre",
    { "lang": "js" },
    [
      "code",
      "function Form() {\n  // 1. Use the name state variable\n  const [name, setName] = useState('Mary');\n\n  // 🔴 We're breaking the first rule by using a Hook in a condition\n  if (name !== '') {\n    useEffect(function persistForm() {\n      localStorage.setItem('formData', name);\n    });\n  }\n\n  // 3. Use the surname state variable\n  const [surname, setSurname] = useState('Poppins');\n\n  // 4. Use an effect for updating the title\n  useEffect(function updateTitle() {\n    document.title = name + ' ' + surname;\n  });\n\n  // ...\n}"
    ]
  ],
  ["p", "假设第二次执行当时候，", ["code", "name"], "为空，则执行顺序如下："],
  [
    "pre",
    { "lang": "js" },
    [
      "code",
      "// ------------\n// 第一次渲染，执行顺序\n// ------------\nuseState('Mary')           // 1. 初始化变量name为'Mary'\nuseEffect(persistForm)     // 2. 针对Form，设置Form行为\nuseState('Poppins')        // 3. 初始化变量surname为'Poppins'\nuseEffect(updateTitle)     // 4. 针对标题，设置相应行为\n\n// -------------\n// 第二次渲染，执行顺序\n// -------------\nuseState('Mary')           // 1. 读取/还原name变量值，并忽略初始化参数\n// useEffect(persistForm)  // 🔴 由于name第二次执行时，name为空，导致此Hooks未执行\nuseState('Poppins')        // 🔴 2 (but was 3). 读取/还原变量surname失败\nuseEffect(updateTitle)     // 🔴 3 (but was 4). 执行updateTitle失败"
    ]
  ],
  ["p", "因此，在使用", ["code", "Hooks"], "时，需要注意以下几点："],
  [
    "ul",
    [
      "li",
      [
        "p",
        "React在多次渲染",
        ["code", "function"],
        "组件时，",
        ["code", "setState"],
        "将被多次调用，为了能正确的让React处理",
        ["code", "state"],
        "，不要将",
        ["code", "Hooks"],
        "放置在条件函数、循环语句或者内嵌函数中，否则可能出现状态管理的异常，而应将",
        ["code", "setState"],
        "， ",
        ["code", "useEffect"],
        "等",
        ["code", "Hooks"],
        "执行放置在最外层。这不仅仅针对",
        ["code", "setState"],
        "，还包括其他",
        ["code", "Hooks"],
        "，如",
        ["code", "useEffect"],
        "等。"
      ]
    ],
    [
      "li",
      [
        "p",
        ["code", "Hooks"],
        "只能在React ",
        ["code", "function"],
        "组件，或者自定义",
        ["code", "hooks"],
        "中使用，请不要在普通的函数中使用。"
      ]
    ]
  ],
  [
    "p",
    "为了自定对以上规则进行检测，React提供了",
    [
      "a",
      {
        "title": null,
        "href": "https://www.npmjs.com/package/eslint-plugin-react-hooks"
      },
      ["code", "eslint-plugin-react-hooks"]
    ],
    "插件，只需集成到ESlint规则中即可。"
  ],
  ["h2", "内置Hooks"],
  [
    "p",
    "根据不同场景，React内置了许多不同的",
    ["code", "Hooks"],
    "，当然，我们也可以定制自己的",
    ["code", "Hooks"],
    "。"
  ],
  ["h3", "基础Hooks"],
  [
    "ol",
    ["li", ["p", ["code", "useState"]]],
    ["li", ["p", ["code", "useEffect"]]],
    ["li", ["p", ["code", "useContext"]]]
  ],
  ["h3", "其他Hooks"],
  [
    "ol",
    ["li", ["p", ["code", "useReducer"]]],
    ["li", ["p", ["code", "useEffect"]]],
    ["li", ["p", ["code", "useEffect"]]],
    ["li", ["p", ["code", "useEffect"]]],
    ["li", ["p", ["code", "useEffect"]]],
    ["li", ["p", ["code", "useEffect"]]],
    ["li", ["p", ["code", "useEffect"]]]
  ]
]
